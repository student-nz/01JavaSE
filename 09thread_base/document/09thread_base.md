# 九、多线程基础（V1）（简单会用）

## 1）什么是线程？

​		线程(thread)就是一个程序内部的一条执行路径

​		main方法的执行其实就是一条单独的执行路径

​		程序中如果只有一条执行路径，那么这个程序就是单线程的程序

## 2）多线程是什么？

​		多线程是指从软硬件上实现多条执行流程的技术

## 3）多线程用在哪里，有什么好处？

​		如：消息通信、淘宝、京东系统都离不开多线程技术

## 4）多线程的创建

​		public Thread(String name)：为当前线程指定名称

​		public Thread(Runnable target)：封装Runnable对象成为线程对象

​		public Thread(Runnable target ，String name )：封装Runnable对象成为线程对象，并指定线程名称

### 	方式一：继承Thread类

​		Java是通过java.lang.Thread 类来代表线程的

​		按照面向对象的思想，Thread类应该提供了实现多线程的方式

#### 	1）实现步骤

​			1. 定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法

​			2. 创建MyThread类的对象

​			3. 调用线程对象的start()方法启动线程（启动后还是执行run方法的）

#### 	2）优缺点：

​			优点：编码简单

​			缺点：线程类已经继承Thread，无法继承其他类，不利于扩展

#### 	3）问题

​		为什么不直接调用了run方法，而是调用start启动线程？

​			直接调用run方法会当成普通方法执行，此时相当于还是单线程执行

​			只有调用start方法才是启动一个新的线程执行

​		如果只有两个线程把主线程任务放在子线程之前了会是什么效果？

​			主线程一直是先跑完的，相当于是一个单线程的效果了

### 方式二：实现Runnable接口

#### 	1）实现步骤

​			1. 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法

​			2. 创建MyRunnable任务对象

​			3. 把MyRunnable任务对象交给Thread处理

​			4. 调用线程对象的start()方法启动线程

#### 	2）优缺点

​		优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强

​		缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的

### 方式三：JDK 5.0新增：实现Callable接口

​		public FutureTask<>(Callable call)：把Callable对象封装成FutureTask对象。

​		public V get() throws Exception：获取线程执行call方法返回的结果

### 	1）实现步骤

​			 1. 得到任务对象

​				定义类实现Callable接口，重写call方法，封装要做的事情

​				用FutureTask把Callable对象封装成线程任务对象

​			2. 把线程任务对象交给Thread处理

​			3. 调用Thread的start方法启动线程，执行任务

​			4. 线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果

### 	2）优缺点

​			优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强

​						可以在线程执行完毕后去获取线程执行的结果		

​			缺点：编码复杂一点

### 	3）3种方式对比

​		![image-20221015173915255](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\3种方式对比.png)

### 	4）Thread常用API

​				String getName()：获取当前线程的名称，默认线程名称是Thread-索引

​				void setName(String name)：将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称

​				public static Thread currentThread()：返回对当前正在执行的线程对象的引用

​				public static void sleep(long time)：让当前线程休眠指定的时间后再继续执行，单位为毫秒

#### 			问题：

​				当有很多线程在执行的时候，我们怎么去区分这些线程呢？

​				我们可以通过getName()、setName()、currentThread()这类API去区分线程

## 5）线程安全

### 	1. 线程安全问题是什么？

​		线程安全问题是指多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题		

### 	2. 线程安全问题出现的原因？

​		多个线程同时访问同一个共享资源且存在修改该资源

## 6）线程同步

### 1. 线程同步解决安全问题的思想是什么？

​	加锁，把共享资源进行上锁，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来

### 2. 线程同步方式

#### 	1）方式一：同步代码块

##### 		1. 作用：

​			把出现线程安全问题的核心代码给上锁

##### 		2. 原理：

​			每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行

##### 		3. 格式：

​			synchronized(同步锁对象) {	

​				操作共享资源的代码(核心代码) 

​			}

##### 		4. 锁对象要求：

​			理论上：锁对象只要对于当前同时执行的线程来说是同一个对象即可

##### 		5. 问题

​			1. 同步代码块是如何实现线程安全的？

​				对出现问题的核心代码使用synchronized进行加锁

​				每次只能一个线程占锁访问

​			2. 锁对象用任意唯一的对象好不好呢?

​				不好，会影响其他无关线程的执行	

​			3. 同步代码块的同步锁对象有什么要求？

​				对于实例方法建议使用this作为锁对象

​				对于静态方法建议使用字节码（类名.class）对象作为锁对象

#### 	2）方式二：同步方法

##### 		1. 作用：

​			把出现线程安全问题的核心方法给上锁

##### 		2. 原理：

​			每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行

##### 		3. 格式：

​			修饰符 synchronized 返回值类型 方法名称(形参列表) {	

​				操作共享资源的代码

​			}

##### 		4. 同步方法底层原理：

​			1. 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码

​			2. 如果方法是实例方法：同步方法默认用this作为的锁对象，但是代码要高度面向对象！

​			3. 如果方法是静态方法：同步方法默认用类名.class作为的锁对象

##### 		5. 问题：

​			1. 解决安全问题是同步代码块好还是同步方法好一点？

​				同步代码块锁的范围更小，同步方法锁的范围更大

​			2. 同步方法是如何保证线程安全的？

​				对出现问题的核心方法使用synchronized修饰

​				每次只能一个线程占锁进入访问

​			3. 同步方法的同步锁对象的原理？

​				对于实例方法默认使用this作为锁对象

​				对于静态方法默认使用类名.class对象作为锁对象

#### 	3）方式三：Lock锁

​			JDK5以后提供了一个新的锁对象Lock，就是为了更清晰的表达如何加锁和释放锁，使用更加灵活、方便

​			Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作

​			Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象

​			public ReentrantLock()：获得Lock锁的实现类对象

​			void lock()：获得锁

​			void unlock()：释放锁

## 7）线程通信

### 	1. 什么是线程通信、如何实现？

​			所谓线程通信就是线程间相互发送数据，线程间共享一个资源即可实现线程通信

### 	2.  线程通信常见形式

​			通过共享一个数据的方式实现

​			根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做

### 	3. 线程通信的应用场景

​			生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据

​			要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己

### 	4. Object类的等待和唤醒方法：

​			void wait()：让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法

​			void notify()：唤醒正在等待的单个线程

​			void notifyAll()：唤醒正在等待的所有线程 

### 	5. 能说说线程通信三个常见方法？

​				void wait()：让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法

​				void notify()：唤醒正在等待的单个线程

​				void notifyAll()：唤醒正在等待的所有线程 

## 8）线程池（具体请看Github之thread_high）

### 1. 什么是线程池？

​	线程池就是一个可以复用线程的技术

### 2. 不使用线程池的问题  

​	如果用户每发起一个请求，后台就创建一个新线程来处理

​	下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能

### 3. 线程池的工作原理

​		![image-20221015173839451](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\线程池的工作原理.png)

### 4. 线程池实现的API、参数说明

#### 	1）谁代表线程池？

​		JDK 5.0起提供了代表线程池的接口：ExecutorService

#### 	2）如何得到线程池对象

##### 		1. 方式一：

​			方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象

​		![image-20221015173730223](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\方式一获的线程池对象.png)

​		ThreadPoolExecutor构造器的参数说明：

​				参数一：指定线程池的线程数量（核心线程）： corePoolSize（不能小于0）

​				参数二：指定线程池可支持的最大线程数： maximumPoolSize（最大数量 >= 核心线程数量）

​				参数三：指定临时线程的最大存活时间： keepAliveTime（不能小于0）

​				参数四：指定存活时间的单位(秒、分、时、天)： unit（时间单位）

​				参数五：指定任务队列： workQueue（不能为null）

​				参数六：指定用哪个线程工厂创建线程： threadFactory（不能为null）

​				参数七：指定线程忙，任务满的时候，新任务来了怎么办： handler（不能为null）			

###### 		1）线程池常见面试题

​			1. 临时线程什么时候创建啊？

​				新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程

​			2. 什么时候会开始拒绝任务？

​				核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝

###### 		2）ExecutorService的常用方法

​				void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable 任务

​				Future<T> submit(Callable<T> task)：执行任务，返回未来任务对象获取线程结果，一般拿来执行 Callable 任务

​				void shutdown() ：等任务执行完毕后关闭线程池

​				List<Runnable> shutdownNow()：立刻关闭，停止正在执行的任务，并返回队列中未执行的任务

###### 		3）新任务拒绝策略

​			ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。是默认的策略

​			ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常 这是不推荐的做法

​			ThreadPoolExecutor.DiscardOldestPolicy：抛弃队列中等待最久的任务 然后把当前任务加入队列中

​			ThreadPoolExecutor.CallerRunsPolicy：由主线程负责调用任务的run()方法从而绕过线程池直接执行

###### 		4）问题	

​			1. 线程池如何处理Runnable任务?

​				使用ExecutorService的方法：void  execute(Runnable target)

​			2. 线程池如何处理Callable任务，并得到任务执行完后返回的结果

​				使用ExecutorService的方法：Future<T> submit(Callable<T> command)

##### 	2. 方式二：

​		Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的

​		方式二：使用线程池的工具类Executors通过调用方法返回不同类型的线程池对象

​		public static ExecutorService newCachedThreadPool()：

​			线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉

​		public static ExecutorService newFixedThreadPool(int nThreads)

​			创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它

​		public static ExecutorService newSingleThreadExecutor ()

​			创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程

​		public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)

​			创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务

###### 		1）Executors使用可能存在的陷阱

​			大型并发系统环境中使用Executors如果不注意可能会出现系统风险

​			![image-20221015175431494](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\Executors使用可能存在的陷阱.png)

![image-20221015175457617](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\Executors使用可能存在的陷阱2.png)

###### 	2）问题

​		1. Executors工具类底层是基于什么方式实现的线程池对象？

​			线程池ExecutorService的实现类：ThreadPoolExecutor

​		2. Executors是否适合做大型互联网场景的线程池方案？

​			不合适，建议使用ThreadPoolExecutor来指定线程池参数，这样可以明确线程池的运行规则，规避资源耗尽的风险

## 9）定时器

### 1. 什么是定时器？

​	定时器是一种控制任务延时调用，或者周期调用的技术

### 2. 作用：

​	闹钟、定时邮件发送

### 3. 定时器的实现方式

#### 1）方式一：Timer定时器

​		public Timer()：创建Timer定时器对象

​		public void schedule(TimerTask task, long delay, long period)：开启一个定时器，按照计划处理TimerTask任务

##### 	1. 特点和存在的问题

​		1. Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入

​		2. 可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行

#### 2）方式二： ScheduledExecutorService定时器

​		ScheduledExecutorService是 jdk1.5中引入了并发包，目的是为了弥补Timer的缺陷, ScheduledExecutorService内部为线程池

##### 		1. Executors的方法:

​			public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)：得到线程池对象

##### 		2. ScheduledExecutorService的方法:

​				public ScheduledFuture<?> scheduleAtFixedRate

​				(Runnable command, long initialDelay, long period,TimeUnit unit)：周期调度方法

###### 			ScheduledExecutorService的优点：

​				基于线程池，某个任务的执行情况不会影响其他定时任务的执行

## 九、（为学高并发打个预防针，本人也待消化）

## 一、多线程概念基础（V2）

### 1）进程和线程

#### 1. 进程：

​	进程是指正在运行的程序，进程拥有一个完整的、私有的基本运行资源集合，通常，每个进程都有自己的内存空间

​	进程往往被看作是程序或应用的代名词

​	然而，用户看到的一个单独的应用程序实际上可能是一组相互协作的进程集合

​	为了便于进程之间的通信，大多数操作系统都支持进程间通信（IPC），如pipes 和sockets，

​	IPC不仅支持同一系统上的通信，也支持不同的系统

​	IPC通信方式包括管道（包括无名管道和命名管道）消息队列、信号量、共享存储、Socket、Streams等方式，

​	其中 Socket和Streams支持不同主机上的两个进程IPC

#### 2. 线程：

​		线程有时也被称为轻量级的进程

​		进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少

​		线程是在进程中存在的 --- 每个进程最少有一个线程

​		线程共享进程的资源，包括内存和打开的文件，这样提高了效率，但潜在的问题就是线程间的通信

​		多线程的执行是Java平台的一个基本特征

​		每个应用都至少有一个线程 – 或几个，如果算上“系统”线程的话，比如内存管理和信号处理等

​		但是从程序员的角度来看，启动的只有一个线程，叫主线程

​		简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程

### 2） 线程启动和停止

#### 1. 启动线程

​	启动线程调用start方法

#### 2. 停止线程

​	线程自带的stop方法，一方面已经过时，另一方面，不会对停止的线程做状态保存，使得线程中涉及的

​	对象处于未知状态，如果这些状态，其他线程也会使用，将会使得其他线程出现无法预料的异常，所

​	以，停止程序的功能，需要自己实现

### 3）线程暂停和中断

#### 1. 暂停

​	Java中线程的暂停是调用 java.lang.Thread 类的 sleep 方法，该方法会使当前正在执行的线程暂停

​	指定的一段时间，如果线程持有锁， sleep 方法结束前并不会释放该锁

#### 2. 中断

​	java.lang.Thread类有一个 interrupt 方法，该方法直接对线程调用

​	当被interrupt的线程正在sleep或wait时，会抛出 InterruptedException 异常

​	事实上， interrupt 方法只是改变目标线程的中断状态（interrupt status），而那些会抛出

​	InterruptedException 异常的方法，如wait、sleep、join等，都是在方法内部不断地检查中断状态的值

##### 1）interrupt方法

​	Thread实例方法：必须由其它线程获取被调用线程的实例后，进行调用。实际上，只是改变了被调用线程的内部中断状态；

###### 	interrupt底层源码实现：

 1. interrupt 中断操作时，非自身打断需要先检测是否有中断权限，这由jvm的安全机制配置；

 2. 如果线程处于sleep, wait, join 等状态，那么线程将立即退出被阻塞状态，并抛出一个

    InterruptedException异常；

 3. 如果线程处于I/O阻塞状态，将会抛出ClosedByInterruptException（IOException的子类）异

    常；

 4. 如果线程在Selector上被阻塞，select方法将立即返回；

 5. 如果非以上情况，将直接标记 interrupt 状态；

    interrupt 操作不会打断所有阻塞，只有上述阻塞情况才在jvm的打断范围内，

    如处于锁阻塞的线程，不会受 interrupt 中断；

    阻塞情况下中断，抛出异常后线程恢复非中断状态，即 interrupted = false

    

​		![image-20221015183135530](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\interrupt底层源码实现.png)

##### 2）Thread.interrupted方法

​	Thread类方法：必须在当前执行线程内调用，该方法返回当前线程的内部中断状态，然后清除中断状态（置为false） 

##### 3）isInterrupted方法

​	Thread实例方法：用来检查指定线程的中断状态。当线程为中断状态时，会返回true；否则返回false

### 4）线程的状态

#### 1. Java线程可能的状态：

![image-20221015183528834](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\Java线程可能的状态.png)

#### 2. 线程的状态变迁

![image-20221015183605355](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\线程的状态变迁.png)

### 5）多线程

​	线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程

​	一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序

#### 1. 并发和并行

​	并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生

​	并行是在不同实体上的多个事件，并发是在同一实体上的多个事件

​	在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务

​	如hadoop分布式集群

#### 2. 多线程好处

##### 1）提高cpu的利用率

​	一般来说，在等待磁盘IO，网络IO或者等待用户输入时，CPU可以同时去处理其他任务（这就是体会到了多线程的强大）

##### 2）更高效的响应

​	多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态，不会造成无法响应的现象

##### 3）公平使用CPU资源

​	当前没有进行处理的任务，可以将处理器时间让给其它任务;占用大量处理时间的任务，也可以定期将

​	处理器时间让给其它任务;通过对CPU时间的划分，使得CPU时间片可以在多个线程之间切换，避免需要

​	长时间处理的线程独占CPU，导致其它线程长时间等待

#### 3. 多线程的代价

##### 1）更复杂的设计

​	共享数据的读取，数据的安全性，线程之间的交互，线程的同步等；

##### 2）上下文环境切换

​	线程切换，cpu需要保存本地数据、程序指针等内容；

##### 3）更多的资源消耗

​	每个线程都需要内存维护自己的本地栈信息，操作系统也需要资源对线程进行管理维护；

# 二、并发编程基础

## 1）临界资源

​	临界资源是一次仅允许一个进程使用的共享资源

​	各进程采取互斥的方式，实现共享的资源称作临界资源

​	属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等

​	诸进程间采取互斥方式，实现对这种资源的共享

## 2）线程安全

### 1. 何谓竞态条件？

​	1. 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。

​	2. 导致竞态条件发生的代码区称作临界区

​	3. 在临界区中使用适当的同步就可以避免竞态条件，如使用synchronized或者加锁机制

### 2. 何谓线程安全

​	1. 允许被多个线程同时执行的代码称作线程安全的代码。线程安全的代码不包含竞态条件

### 3. 对象的安全

#### 1）局部基本类型变量

​	1. 局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享，所以，基础类型的局部变量是线程安全的

#### 2）局部的对象引用

​	1. 对象的局部引用和基础类型的局部变量不太一样，尽管引用本身没有被共享，但引用所指的对象并没有

​	存储在线程的栈内。所有的对象都存在共享堆中

​	2. 如果在某个方法中创建的对象不会逃逸出（即该对象不会被其它方法获得，也不会被非局部变量引用

​	到）该方法，那么它就是线程安全的。

​	3. 实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的

#### 3）对象成员(成员变量)

​	1. 对象成员存储在堆上，如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的

​	2. 如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。

#### 4）不可变性

​	通过创建不可变的共享对象来保证对象在线程间共享时不会被修改，从而实现线程安全

## 3）Java内存模型

​		1. Java内存模型即Java Memory Model，简称JMM

​		2. JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式，JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的

### 1. 线程之间的通信

​	1. 线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内存和消息传递

​	2. 在共享内存的并发模型里，线程之间共享程序的公共状态，

​	线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信

​	3. 在消息传递的并发模型里，线程之间没有公共状态

​	线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()

### 2. 线程之间的同步

1. 同步是指程序用于控制不同线程之间操作发生相对顺序的机制

 2. 在共享内存并发模型里，同步是显式进行的

    程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行

3. 在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，

   因此同步是隐式进行的，Java的并发采用的是共享内存模型

4. Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明

   如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题

### 3. Java内存模型结构

​	Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见

​	从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）

​	中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量

​	的副本。本地内存是JMM的一个抽象概念，并不真实存在。

​	它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化

​	![image-20221015190235082](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\Java内存模型结构.png)

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

​	1.  首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去

​	2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量

## 4）CAS乐观锁

### 	1. 乐观锁：

​			1. 乐观锁：不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。

​							其实现方式有一种比较典型的就是Compare and Swap( CAS )

​			2. CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

​				更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，

​				才会将内存地址V对应的值修改为B。

​			3. 从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。

​				CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新	

### 	2. CAS的缺点：

#### 		1）CPU开销较大

​			在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，

​			却又一直更新不成功，循环往复，会给CPU带来很大的压力

#### 		2）不能保证代码块的原子性		

​			CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。

​			比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了

## 5）Synchronized块

​		Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。

​		所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。

​		所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出

### 1. 四种不同的同步块：

#### 	1）实例方法

​		实例方法同步即方法声明中同步（synchronized ）关键字

​		Java实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，

​		即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线

​		程一次可以在一个实例同步块中执行操作

#### 	2）静态方法

​		1. 静态方法同步和实例方法同步方法一样，也使用synchronized 关键字

​			同样，这里synchronized 关键字告诉Java这个方法是同步的

​		2. 静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象，

​			所以同时只允许一个线程执行同一个类中的静态同步方法。

​		3. 对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那

​			个静态同步方法被调用，一个类只能由一个线程同时执行

#### 	3）实例方法中的同步块

​			1. 有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步

​			2. 注意Java同步块构造器用括号将对象括起来，在同步构造器中用括号括起来的对象叫做监视器对象

​			3. 一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行

#### 	4）静态方法中的同步块

​			这些方法同步在该方法所属的类对象上

​			如果两个静态方法的同步块是同步在同一个类对象上，那么这两个方法不可以同时被线程访问

### 2. Synchronized锁的存储

​			synchronized用的锁存储在Java对象头，如果对象是数组类型，则虚拟机用3个字宽存储对象头，

​			如果对象是非数组类型，则用2字宽存储对象头，32位虚拟机，1字宽等于4字节，即32位

#### 1）Java对象头的长度

​		![image-20221015191921246](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\Java对象头的长度.png)

#### 2）Mark Word的存储结构

​		![image-20221015191940525](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\Mark Word的存储结构.png)

#### 3）Mark Word可能的存储结果

​		![image-20221015192014875](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\Mark Word可能的存储结果.png)

#### 4）偏向锁

##### 偏向锁的获取流程：

（1） 查看Mark Word中偏向锁的标识以及锁标志位，若是否偏向锁为1且锁标志位为01，则该锁为可偏向状态

（2）若为可偏向状态，则测试Mark Word中的线程ID是否与当前线程相同，

​		若相同，表示线程已经获得了锁，如果不同，则进入（3）

 （3）测试Mark Word的偏向锁的标识是否设置为1，如果没有设置，则使用CAS操作竞争锁，

​		如果设置了，则尝试使用CAS尝试将Mark Word中线程ID设置为当前线程ID，如果尝试失败，则执行（4）

 （4）当前线程通过CAS竞争锁失败的情况下，说明有竞争。

​		当到达全局安全点（在这个时间点，没有正在执行的代码）时之前获得偏向锁的线程被挂起，

​		偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码

#### 5）轻量级锁

​	轻量级锁不是用来替代传统的重量级锁的，而是在没有多线程竞争的情况下，

​	使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会膨胀为重量级锁

##### 轻量级锁的加锁过程：

（1）当线程执行代码进入同步块时，若Mark Word为无锁状态，虚拟机先在当前线程的栈帧中建立一

​	个名为Lock Record的空间，用于存储当前对象的Mark Word的拷贝，官方称之为“Dispalced Mark

​	Word”，此时状态如下图：

​	![image-20221015192348588](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\轻量级锁的加锁过程1.png)

（2）复制对象头中的Mark Word到锁记录中

（3）复制成功后，虚拟机将用CAS操作将对象的Mark Word更新为执行Lock Record的指针，并将

​		Lock Record里的owner指针指向对象的Mark Word。如果更新成功，则执行4，否则执行5。；

（4）如果更新成功，则这个线程拥有了这个锁，并将锁标志设为00，表示处于轻量级锁状态，此时状

态图：

![image-20221015192423491](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\09thread_base\document\assets\轻量级锁的加锁过程4.png)

（5）如果更新失败，则说明有其他线程竞争锁，当前线程便通过自旋来获取锁。轻量级锁就会膨胀为

​	重量级锁，Mark Word中存储重量级锁（互斥锁）的指针，后面等待锁的线程也要进入阻塞状态

#### 6）重量级锁

​	即当有其他线程占用锁时，当前线程会进入阻塞状态

## 6）关键字Volatile

​	Volatile是轻量级的synchronized,在多处理器环境下，可以保证共享变量的可见性。

​	它不会引起线程上下文的切换和调度，正确的使用Volatile,比synchronized的使用和执行成本更低

### 1. 可见性：

可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。

也就是一个线程修改一个共享变量时，另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性

volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。

但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。

比如 volatile int a = 0；之后有一个操作 a++；

这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题

在 Java 中 volatile、synchronized 和 final 实现可见性

### 2. 原子性：

原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不

可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割

的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术

（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。

java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。

比如：AtomicInteger、AtomicLong、AtomicReference等。

在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性

### 3. 有序性：

1. Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，

​		volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时

​		刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步

​		块只能串行执行

2. Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。

   当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该

​		变量上的操作与其他内存操作一起重排序。

​		volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

​		在访问volatile变量时不会执行加锁操作，

​		因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。

​	3. 当一个变量定义为 volatile 之后，将具备两种特性：

​		1）保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个

​			变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普

​			通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成

​		2）禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0,

​			(%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏

​			障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU

​			采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。

## 7）本地线程

​	Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。

​	因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，

​	它们也无法访问到对方的ThreadLocal变量。

### 	1. 如何创建ThreadLocal变量

​		private ThreadLocal myThreadLocal = new ThreadLocal(); 

​		我们可以看到，通过这段代码实例化了一个ThreadLocal对象。

​		我们只需要实例化对象一次，并且也不需要知道它是被哪个线程实例化。

​		虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程却只能访问到自己通过调用ThreadLocal的set()方法设置的值。

​		即使是两个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值。

### 	2. 如何访问ThreadLocal变量

​		一旦创建了一个ThreadLocal变量，你可以通过如下代码设置某个需要保存的值：

​		myThreadLocal.set("A thread local value”); 

​		可以通过下面方法读取保存在ThreadLocal变量中的值：

​		String threadLocalValue = (String) myThreadLocal.get(); 

## 8）多线程问题

### 1. 死锁

#### 	1）死锁的产生

​		死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。

​		死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候

​		例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这

​		时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事

​		情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。

​		该情况如下：

​			Thread 1 locks A, waits for B

​			Thread 2 locks B, waits for

#### 2）更复杂的死锁

​	死锁可能不止包含2个线程，这让检测死锁变得更加困难。下面是4个线程发生死锁的例子：

​	Thread 1 locks A, waits for B

​	Thread 2 locks B, waits for C

​	Thread 3 locks C, waits for D

​	Thread 4 locks D, waits for A

​	线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。

#### 3）数据库的死锁

​	更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事

​	务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务

​	中每一个更新请求都可能会锁住一些记录。

​	当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：

​	Transaction 1, request 1, locks record 1 for update

​	Transaction 2, request 1, locks record 2 for update

​	Transaction 1, request 2, tries to lock record 2 for update.

​	Transaction 2, request 2, tries to lock record 1 for update.

​	因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，

​	因此很难检测和避免数据库事务中的死锁

#### 4）死锁的避免

##### 1. 加锁顺序

​	当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生

​	如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。看下面这个例子

​	Thread 1:

​		lock A

​		lock B

​	Thread 2:

​		wait for A

​		lock C (when A locked)

​	Thread 3:

​		wait for A

​		wait for B

​		wait for C

1. 如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上

​	排在前面的锁之后，才能获取后面的锁。

2. 例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条

​	件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁

​	之前，必须成功地对A加了锁。

​	3. 按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者

​		注：并对这些锁做适当的排序)，但总有些时候是无法预知的

##### 2. 加锁时限

另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过

程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的

锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让

其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加

锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)

以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场

景：

Thread 1 locks A

Thread 2 locks B

Thread 1 attempts to lock B but is blocked

Thread 2 attempts to lock A but is blocked

Thread 1's lock attempt on B times out

Thread 1 backs up and releases A as well

Thread 1 waits randomly (e.g. 257 millis) before retrying.

Thread 2's lock attempt on A times out

Thread 2 backs up and releases B as well

Thread 2 waits randomly (e.g. 43 millis) before retrying.

1. 在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，

​	线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2

​	或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。

2. 需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获

​	得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。

3. 此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些

​	线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，

​	这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间

​	的概率就高的多（或者非常接近以至于会出现问题）。

4. 这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义

​	锁，或使用Java5中java.util.concurrent包下的工具。写一个自定义锁类不复杂，但超出了本文的

​	内容。后续的Java并发系列会涵盖自定义锁的内容。

##### 3. 死锁检测

1. 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。

​	2. 每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，

​		每当有线程请求锁，也需要记录在这个数据结构中。

​	3. 当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，

​		但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的

​		锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请

​		求锁1）。

​	4. 当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线

​		程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的

​		锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自

​		己持有着。这是它就知道发生了死锁。

​	5. 那么当检测出死锁时，这些线程该做些什么呢？

​		一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，

​		不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如

​		果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）

​	6. 一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一

​		样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的

​		优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。

### 2. 饥饿和公平

​	如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而

​	该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为“公平性” –

​	即所有线程均能公平地获得运行机会

#### 1）Java中导致饥饿的原因

​	在Java中，下面三个常见的原因会导致线程饥饿：

​	1. 高优先级线程吞噬所有的低优先级线程的CPU时间

​		你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设

​		置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应

​		用来说，你最好是不要改变其优先级值。

 2. 线程被永久堵塞在一个等待进入同步块的状态

    Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有

    任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他

    线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它

    得不到CPU运行时间的机会。

​	3. 线程在等待一个本身(在其上调用wait())也处于永久等待完成的对象

​		如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任

​		何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因

​		为其他等待线程总是能被获得唤醒。

# 9）与线程相关的方法（详解后续更新，多线程太难了）

### 1. 获取当前线程对象：currentThread()

### 2. 获取当前线程名称：getName()

### 3. 启动线程：start

​	只有调用start方法才是启动一个新的线程执行

### 4. 停止线程：stop

​	强制停止一个正在运行的线程, 无论此时线程是何种状态, 非常不安全

### 5. 休眠线程：sleep

​	让线程休眠指定的时间，单位为毫秒

### 6. 指定线程任务：run

​	启动线程后执行该run方法封装的线程任务

### 7. 精灵线程：setDaemon


​	普通线程执行结束,守护线程也不再继续执行

### 8. 获取线程状态：getState

​	获取当前线程状态（六大状态）

### 9. 中断线程相关

#### 1）interrupt()

作用：interrupt方法只改变中断状态, 不会中断一个正在运行的线程

##### 阻塞与非阻塞状况：

###### 阻塞状况：

​	调用interrupt方法抛出InterruptedException异常的方法，如wait、sleep、join等，都是在方法内部不断地检查中断状态的值

###### 非阻塞状况：

​	调用interrupt方法, 不抛出InterruptedException异常的方法，因为在方法内部并未有检查中断状态的值

#### 2）interrupted()

​	必须在当前执行线程内调用，该方法返回当前线程的内部中断状态（true)，然后清除中断状态（置为false）

#### 3）isInterrupted(boolean ClearInterrupted)

​		参数代表是否清除中断状态

### 10. 等待线程死亡：join

​		等待当前线程死亡

### 11. 堵塞进程：park

​		堵塞以及不堵塞进程

### 12. 线程优先级：priority

​	设置以及获取线程优先级

### 13. 等待线程：wait

​	等待其它线程唤醒

### 14. 唤醒等待线程：notify、notifyAll

​	唤醒正在等待中的其中一个线程或唤醒所有正在等待的线程

### 15. 让出CPU使用权：yield

​	让出当前线程的cpu执行权，使得线程由运行状态变为就绪状态,等下调用时再执行

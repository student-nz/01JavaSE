# 二、OOP

# 1. 什么是面向对象编程

```
1. 首先面向对象不是一种技术, 而是一种编程指导思想

2. 面向对象编程(Object Oriented Programming)就是把现实世界的具体事物全部看成一个一个的对象来解决问题
```

# 2. 为什么要用面向对象编程

```
让程序更符合人类的思维习惯
```

# 3. 类与对象的关系

```
1. 类是对象共同特征的抽象描述，也就是一类具有共同属性和行为的事物的抽象

2. 对象就是真实存在的具体实例

3. 在Java中,必须先设计类,才能获得对象
```

## 	1. 类的组成

```
类由属性和行为组成
	1. 属性：
		在类中通过成员变量来体现（类中方法外的变量）
	
	2. 行为：
		在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）
```

## 	2. 如何定义类

### 				1. 定义类规范

```
1. 类名首字母大写（满足大驼峰模式）
2. 一个Java文件中可以定义多个class类, 但只能一个类是public修饰（称为主类）
3. public修饰的类名必须成为代码文件名
```

### 			2. 成员变量完整定义格式

```
修饰符 数据类型 变量名称 = 初始化值；(一般无需指定初始化值，存在默认值)
```

## 	3. 对象成员变量默认赋值规则

### 						1. 基本数据类型

```
byte、short、char、int、long（默认值 0）

float、double（默认值 0.0）

boolean	（默认值 false）
```

### 						2. 引用类型		

```
类、接口、数组、String （默认值 null）
```

## 4. 如何得到类的对象

```
类名 对象名 = new 类名();
```

## 5. 如何使用对象访问成员

```
1. 访问属性：
	对象名.成员变量

2. 访问行为：
	对象名.方法名(...)
```

## 6. 对象内存图

```
对象存放在堆内存

对象变量存放在栈内存, 存储的是对象在堆内存中的地址

成员变量的数据存储在对象中, 存储在堆内存中
```

![image-20221010083604570](assets\对象内存图1.png)

![image-20221010083843258](assets\两个变量指向同一对象内存图.png)

## 7. 垃圾回收机制

```
当堆内存中的类对象或数组对象, 没有被任何变量引用（指向）时

就会被判定为内存中的“垃圾”,同时Java存在自动垃圾回收器，会定期进行清理
```

## 8. 构造器

```
构造器就是用于初始化一个类的对象,并返回对象的地址
```

### 	1. 定义格式

```
修饰符 类名(形参列表){
	. . .
}
```

### 	2. 初始化对象格式

```
类名 对象名称 = new 构造器;
```

### 	3. 构造器分类

#### 					1. 无参构造器

```
无参数构造器(默认存在)：初始化对象时,成员变量的数据均采用默认值初始化
```

#### 					2. 有参构造器

```
有参数构造器：初始化对象时,同时可以为对象进行赋值		
```

#### 			3. 构造器使用细节		

```
任何类定义出来, 默认都自带无参数构造器

一旦定义有参数构造器, 无参数构造器就不再提供
```

## 	9. this关键字

```
this关键字出现在成员方法、构造器中, 代表当前对象的地址
```

### 		1.作用

```
this代表当前对象的地址,用于访问当前对象的成员变量、成员方法
```

### 				2. this出现在有参数构造器中的用法

```
public Car(String name,double price){
	this.name = name;
	this.price = price;
}
```

### 			3. this出现在成员方法中的用法

```
public void goWith(String name){
	System.out.println(this.name + “正在和” + name + “一起比赛 !  !  !”)	
}
```

### 		4. 成员变量和局部变量的区别

![image-20221010085453785](assets\成员变量和局部变量的区别.png)

## 10. static关键字

```
static是静态的意思, 可以修饰成员变量和成员方法

static修饰成员变量表示该成员变量在内存中只存储一份,可以被共享访问、修改

在加载类的时候，static修饰的内容就会被加载进内存
```

### 		1. 成员变量分类

#### 					1. 静态成员变量

```
静态成员变量(有static修饰, 属于类, 内存中加载一次): 常表示如在线人数信息、等需要被共享的信息，可以被共享

访问：
	类名.静态成员变量（推荐）
	对象.静态成员变量（不推荐）
```

#### 					2. 实例成员变量

```
实例成员变量(无static修饰, 存在于每个对象中)：常表示姓名name、年龄age等属于每个对象的信息

访问：
	对象.实例成员变量
```

### 		2. static修饰成员变量内存原理			![image-20221010113341415](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\02OOP\document\assets\static修饰成员变量内存原理.png)

### 	3. 成员方法分类

#### 						1. 静态成员方法

```
静态成员方法(有static修饰,属于类),可以用类名访问（工作写法）,也可以用对象访问

访问：
	类名.静态成员方法（标准写法）
	对象.静态成员方法（不推荐）
```

#### 						2. 实例成员方法

```
实例成员方法(无static修饰, 属于对象), 只能用对象触发访问

访问：
	对象.实例成员方法
```

#### 				3. 两者使用场景

```
1. 表示对象自己行为且方法中需要访问实例成员的,则可以声明成实例方法

2. 执行一个共用功能为目的,则可以声明成静态方法
```

### 			4. static修饰成员方法内存原理

![image-20221010114600871](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221010114600871.png)

### 5. static访问问题

```
1. 静态方法只能访问静态的成员, 不可以直接访问实例成员

2. 实例方法可以访问静态的成员, 也可以访问实例成员

3. 静态方法中是不可以出现this关键字的
```

## 11. 工具类

```
工具类中定义的都是一些静态方法,每个方法都是以完成一个共用的功能为目的
```

#### 				1. 如何定义工具类？

​				1. 建议将工具类的构造器进行私有, 工具类无需创建对象

​				2. 里面都是静态方法，直接用类名访问即可

#### 				2. 工具类是什么,有什么好处？

​				1. 内部都是一些静态方法, 每个方法完成一个功能

​				2. 一次编写, 处处可用, 提高代码的重用性

#### 				3. 定义工具类有什么要求？

​				1. 建议工具类的构造器都私有化处理

​				2. 工具类不需要创建对象				



## 12. 代码块

```
代码块是类的5大成分之一(成员变量、构造器，方法，代码块，内部类), 定义在类中方法外

在Java类下,使用 { } 括起来的代码被称为代码块

代码块分为四类：普通代码块、构造代码块、静态代码块、同步代码块
```

#### 		 1. 普通代码块: 

```
类中方法的方法体, 又称为局部代码块
```

#### 	     2. 构造代码块

```
构造代码块又称成员代码块, 会在创建对象时被调用,每次创建时都会被调用,优先于类构造函数执行

格式：{}

使用场景：初始化实例资源
```

#### 				3. 静态代码块

```
静态代码块又称静态成员代码块, 用static{}包裹起来的代码片段,只会执行一次, 静态代码块优先于构造代码块执行

格式：static{}

使用场景：静态代码块可用来初始化一些项目最常用的变量或对象
```

#### 		4. 同步代码块

```
多线程环境下, 对共享数据的读写操作是需要互斥进行的, 否则会导致数据的不一致性, 

同步代码块需要写在方法中

格式：synchronized( ){}

使用场景：把出现线程安全问题的核心代码给上锁
```

## 13. 面向对象三大特征

### 		1. 封装

```
封装就是合理隐藏、合理暴露, 例如：private修饰隐藏属性, 提供public修饰公开的getter、setter方法暴露其取值和赋值
```

#### 					1. 封装的好处

```
1. 加强了程序代码的安全性

2. 适当的封装可以提升开发效率,同时可以让程序更容易理解与维护程序
```

#### 				2. 标准JavaBean

```
JavaBean可以理解成实体类, 其对象可以用于在程序中封装数据
```

#### 						3. 标准JavaBean须满足三个条件

```
1. 成员变量使用private修饰

2. 提供每一个成员变量对应的setXxx() / getXxx()

3. 必须提供一个无参构造器
```

​				![image-20221010085050533](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\02OOP\document\assets\封装.png)

### 		2. 继承

```
继承就是java允许我们用extends关键字, 让一个类和另一个类建立起一种父子关系

即把实例对象相同的属性和行为抽离出来, 以降低重复代码的书写
```

#### 				1. 继承好处		

```
提高代码复用性, 减少代码冗余,增强类的功能扩展性,

因为当子类继承父类后, 就可以直接使用父类公共的属性和方法
```

#### 				2. 继承设计规范

```
子类们相同特征(共性属性、共性方法)放在父类中定义, 子类独有的的属性和行为应该定义在子类自己里面

为什么这样做？
	如果子类的独有属性、行为定义在父类中, 会导致其它子类也会得到这些属性和行为, 这不符合面向对象逻辑
```

#### 				3. 继承特点

```
1. 子类可以继承父类的属性和行为, 但是子类不能继承父类的构造器

2. Java是单继承模式：一个类只能继承一个直接父类

3. Java不支持多继承、但是支持多层继承。

4. Java中所有的类都是Object类的子类/间接子类
```

#### 				4. Object特点	

```
Object是祖宗类, Java中所有类,要么直接继承了Object ,要么默认继承了Object , 要么间接继承了Object
```

#### 				5. 继承后的问题

​		

```
1. 继承后：成员变量、成员方法的访问特点
	就近原则，子类没有找子类、子类没有找父类、父类没有就报错！
		1. 先子类局部范围找
		2. 然后子类成员范围找
		3. 然后父类成员范围找，如果父类范围还没有找到则报错
			如果子父类中, 出现了重名的成员, 会优先使用子类的, 但是如果一定要在子类中使用父类的怎么办？
			可以通过super关键字, 指定访问父类的成员

2. 继承后：方法重写
	方法重写即子类出现了和父类中一模一样的方法声明
	1. 方法重写的应用场景：
		当子类需要父类的功能, 但父类的该功能不完全满足自己的需求时, 子类可以重写父类中的方法

	2. @Override重写注解
		@Overridez注解校验该方法是否为重写方法（重写方法都建议使用@Override注解，工作写法）
		1. 重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致
		2. 私有方法不能被重写
		3. 子类重写父类方法时，访问权限必须大于或者等于父类
		4. 子类不能重写父类的静态方法, 如果重写会报错的

3. 继承后：子类构造器的特点：
	子类中所有的构造器默认都会先访问父类中无参的构造器，再执行自己
	1. 为什么？
		子类在初始化的时候, 有可能会使用到父类中的数据, 如果父类没有完成初始化, 子类将无法使用父类的数据
		所以子类初始化之前, 一定要调用父类构造器先完成父类数据空间的初始化
	2. 怎么调用父类构造器的？
		子类构造器的第一行语句默认都是：super(), 不写也存在
		所以子类中所有的构造器默认都会先访问父类中无参的构造器, 再执行自己

4. 继承后：子类构造器访问父类有参构造器
	1. super调用父类有参数构造器的作用							
		通过调用父类有参数构造器来初始化继承自父类的数据
	2. 如果父类中没有无参数构造器，只有有参构造器，会出现什么现象呢？
		会报错, 因为子类默认是调用父类无参构造器的	
		如何解决？
			子类构造器中可以通过书写 super(…)，手动调用父类的有参数构造器
```

### 3. 多态

```
多态即同类型的对象, 执行同一个行为, 会表现出不同的行为特征
```

#### 		1. 多态常见形式

```
父类类型 对象名称 = new 子类构造器;

接口 对象名称 = new 实现类构造器;
```

#### 		2. 多态中成员访问特点

```
方法调用：编译看左边，运行看右边

变量调用：编译看左边，运行也看左边（因为多态侧重行为多态）
```

#### 		3. 多态的前提

```
有继承/实现关系；

有父类引用指向子类对象；

有方法重写
```

#### 			4. 多态使用的优势		

```
在多态形式下, 右边对象可以实现解耦合, 便于扩展和维护

后续业务行为随对象而变, 后续代码无需修改

定义方法的时候, 使用父类型作为参数, 该方法就可以接收这父类的一切子类对象, 体现出多态的扩展性与便利
```

#### 		5. 使用多态产生的问题:

```
多态下不能使用子类的独有功能
```

#### 		6. 多态下引用数据类型的类型转换

##### 					1. 自动类型转换		

```
自动类型转换（从子到父)：子类对象直接赋值给父类类型的变量指向
```

##### 					2. 强制类型转换

```
强制类型转换（从父到子)：子类 对象变量 = (子类)父类类型的变量

强制类型转换作用：
	可以解决多态下的劣势, 可以实现调用子类独有的功能

强制类型转换注意：
	如果转型后的类型和对象真实类型不是同一种类型, 那么在转换的时候就会出现ClassCastException
	Java建议强转转换前使用instanceof判断当前对象的真实类型，再进行强制转换
	
	变量名 instanceof 真实类型;
	
	判断关键字左边的变量指向的对象的真实类型, 是否是右边的类型或者是其子类类型, 是则返回true, 否则,返回false
```



## 11. this和super比较

```
this：代表本类对象的引用

super：代表父类存储空间的标识
```

​		![image-20221010122947958](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\02OOP\document\assets\this和super比较.png)

## 12. 包	

```
包就是是用来分门别类的管理各种不同类的, 类似于文件夹、建包利于程序的管理和维护
```

### 			1. 建包语法

```
package 公司域名倒写.技术名称, 包名建议全部英文小写, 且具备意义

建包语句必须在第一行
```

### 			2. 导包语法

```
相同包下的类可以直接访问, 不同包下的类必须导包,才可以使用

导包格式：import 包名.类名; 

假如一个类中需要用到不同类m, 而这个两个类的名称是一样的, 那么默认只能导入一个类, 另一个类要带包名访问
```

### 3. 实例

```
普通方式导入一个类
	import com.yj.nz.oop.oop2.demo1.Student;

静态导入导入另一个类的静态成员
	import static com.yj.nz.oop.oop2.demo1.Student.aaa;
	import static com.yj.nz.oop.oop2.demo1.Student.bbb;

通配符导入 类下所有的静态成员  静态成员变量和静态成员方法
	import static com.yj.nz.oop.oop2.demo1.Student.*;
```

### 4. 特殊情况

```
开发中,可以直接使用java.lang包下的类,因为java.lang包下的所有类, 系统会自动导入,无需手动导入
```

## 13. 权限修饰符

```
权限修饰符就是用来控制一个成员能够被访问的范围的

可以修饰成员变量，方法，构造器，内部类，不同权限修饰符修饰的成员能够被访问的范围限制

权限修饰符有四种作用范围：由小到大（private -> 缺省 -> protected - > public ）
```

​			   ![ ](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\02OOP\document\assets\权限修饰符.png) 

​		

```
如何使用权限修饰符：
	1. 成员变量一般私有
	2. 方法一般公开
	3. 如果该成员只希望本类访问,使用private修饰
	4. 如果该成员只希望本类, 同一个包下的其他类和子类访问, 使用protected修饰
	5. 如果该成员希望任意包任意类访问, 使用public修饰
```

## 14. final关键字

```
final关键字是最终的意思, 可以修饰方法, 变量, 类

修饰方法：
	表明该方法是最终方法, 不能被重写

修饰变量：
	表示该变量第一次赋值后, 不能再次被赋值(有且仅能被赋值一次)
		如果final修饰的变量是基本类型：那么变量存储的数据值不能发生改变
		如果final修饰的变量是引用类型：那么变量存储的地址值不能发生改变, 但是地址指向的对象内容是可以发生变化的

修饰类：
	表明该类是最终类, 不能被继承
```

## 15）常量

​		常量是使用了public static final修饰的成员变量,必须有初始化值, 而且执行的过程中其值不能被改

### 			1. 常量命名规范：

​				英文单词全部大写，多个单词下划线连接起来

### 			2. 常量的作用和好处

​					常量可以用于做系统的配置信息, 方便程序的维护,同时也能提高可读性

### 			3. 常量的执行原理

​					在编译阶段会进行“宏替换”, 把使用常量的地方全部替换成真实的字面量

​					这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的

​					注意：前面所提到的常量就是等同于字面量, 只是提前让大家知道常量是什么罢了！

### 	4. 常量做信息标志和分类

​			选择常量做信息标志和分类使得代码可读性好, 实现了软编码形式

## 16）枚举

​			枚举是Java中的一种特殊类型

### 			1. 枚举的作用

​				枚举就是为了做信息的标志和信息的分类

### 			2. 定义枚举类的格式

​				![image-20221010130348105](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\02OOP\document\assets\定义枚举类的格式.png)

### 			3. 反编译后观察枚举的特征

​				![image-20221010130501506](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\02OOP\document\assets\反编译后观察枚举的特征.png)

## 17）常量和枚举信息标志选择

#### 		1. 选择常量做信息标志和分类

​				虽然可以实现可读性, 但是入参值不受约束,代码相对不够严谨

#### 			2. 枚举做信息标志和分类

​				代码可读性好, 入参约束严谨, 代码优雅, 是最好的信息分类技术（建议使用）

## 18）抽象类

​			一个类中的某个方法的具体实现不能确定就可以声明成abstract修饰的抽象方法(不能写方法体)

​			含有抽象方法的类, 必须定义为抽象类, 即这个类必须用abstract修饰

#### 		1. 什么是抽象类

​				用abstract修饰的类

​				格式：修饰符 abstract class 类

#### 		2. 抽象方法

​				只有方法签名, 没有方法体,使用了abstract修饰

​				格式：修饰符 abstract 返回值类型 方法名称(形参列表);

#### 		3. 抽象类作用

​				抽象类就是用来被子类继承、充当模板的、同时也可以提高代码复用

#### 		4. 继承抽象类需要做什么？

​				一个类如果继承了抽象类, 那么这个类必须重写完抽象类的全部抽象方法

​				或者这个类也是抽象类

#### 		5. 抽象类为什么不能创建对象？

​				有得有失: 得到了抽象方法, 那就失去了创建对象的能力, 自己都不知道自己干什么, 创建对象毫无意义

​				类有的成员（成员变量、方法、构造器）, 抽象类都具备

​				抽象类中不一定有抽象方法, 有抽象方法的类一定是抽象类

​				一个类继承了抽象类必须重写完抽象类的全部抽象方法, 否则这个类也必须定义成抽象类

​				不能用abstract修饰变量、代码块、构造器

#### 		6. final和abstract是什么关系？

​				1. 互斥关系

​				2. abstract定义的抽象类作为模板让子类继承, final定义的类不能被继承

​				3. 抽象方法定义通用功能让子类重写, final定义的方法子类不能重写

## 19）接口

​		接口是一种规范

​			在Java中, 接口用关键字interface来定义

​			JDK8之前接口中只能是抽象方法和常量, 没有其他成分

​			接口不能实例化

​			接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化

#### 		1）格式：

​				public interface 接口名 {      

​		 				// 常量       

​						// 抽象方法

​				} 

#### 			2. 接口实现类

​				接口是用来被类实现（implements）的, 实现接口的类称为实现类（可以理解成所谓的子类）

​				接口可以被类单实现，也可以被类多实现

​				一个类实现接口, 必须重写完全部接口的全部抽象方法, 否则这个类需要定义成抽象类

##### 				1）格式：

​							修饰符 class 实现类 implements 接口1, 接口2, 接口3 , ... {

​							}

#### 	3. 接口与接口的关系

​				接口与接口的关系：多继承, 一个接口可以同时继承多个接口

​				类和类的关系：单继承, 一个类只能继承一个类

​				类和接口的关系：多实现, 一个类可以实现多个接口

​				接口多继承的作用：规范合并, 整合多个接口为同一个接口, 便于子类实现

#### 			4. JDK版本升级后接口规范的变化

​					JDK8版本开始后, Java只对接口的成员方法进行了新增

##### 						1）为什么新增接口规范？

​							如何能在丰富接口功能的同时又不对子类代码进行更改呢？

​							允许接口中直接定义带有方法体的方法

##### 						2）JDK8新增

###### 									1）新增默认实例方法：

​								必须用default修饰, 而不是缺省修饰

​								需要用接口的实现类的对象来调用

​								default void run(){   

​										 System.out.println("--开始跑--");

​								}

###### 									2）新增静态方法

​							必须static修饰	

​							接口的静态方法必须用本身的接口名来调用

##### 						2）JDK9新增

​					1）新增私有实例方法

​							必须使用private修饰,

​							只能在本类中被其他的默认方法或者私有方法访问

​							private void go(){    

​								System.out.println("--准备--");

​							}

##### 					3）JDK8后新增了哪些方法？

​			1. 默认方法：default修饰，实现类对象调用

​			2. 静态方法：static修饰，必须用当前接口名调用

​			3. 私有方法：private修饰，jdk9开始才有的，只能在接口内部被调用

#### 		5. 使用接口的要求

​				1. 接口不能创建对象

​				2. 一个类实现多个接口, 多个接口中有同样的静态方法不冲突

​				3. 一个类继承了父类, 同时又实现了接口,父类中和接口中有同名方法, 默认用父类的

​				4. 一个类实现了多个接口, 多个接口中存在同名的默认方法,不冲突,这个类重写该方法即可

​				5. 一个接口继承多个接口,是没有问题的,如果多个接口中存在规范冲突则不能多继承

#### 6. 接口特点：

​	1. 接口中的所有方法都是抽象方法，不能包含方法的实现

​	2. 接口中的所有方法的访问修饰权限都是public，不写并不是默认访问权限，而是public

​	3, 接口不能被实例化

​	4. 接口的子类必须要实现接口中的所有方法，跟抽象类有所不同，抽象类中的抽象方法必须要被子类实现，普通方法可以不重写

​	5. 子类可以实现多个接口

 6. 接口中的变量都是静态常量，如果没有使用static关键字修饰，它默认也表示静态常量，不用final关键字修饰，

    默认也是常量，不能修改

​	7. 接口中的方法和常量无论是否添加public修饰，默认的权限有且仅有一个，就是public

## 20）内部类

​			内部类就是定义在一个类里面的类,里面的类可以理解成（寄生）, 外部类可以理解成（宿主）

### 		1. 格式：

​					public class People{    

​							// 内部类   

​							 public class Heart{    

​							}

​					}

### 		2. 内部类的使用场景与作用

​				1. 当一个事物的内部, 还有一个部分需要一个完整的结构进行描述,而这个内部的完整的结构又只为外部事物提供服务

​				那么整个内部的完整结构可以选择使用内部类来设计

​				2. 内部类通常可以方便访问外部类的成员, 包括私有的成员

​				3. 内部类提供了更好的封装性, 内部类本身就可以用private protectecd等修饰, 封装性可以做更多控制

### 		3. 内部类的分类

#### 						1）静态内部类

​							静态内部类就是有static修饰的内部类, 属于外部类本身

​							静态内部类的特点和使用与普通类是完全一样,类有的成分它都有, 只是位置在别人里面而已

​						格式：

​							public class Outer{       

​									// 静态成员内部类       

​									public static class Inner{        

​									}

​							}

​						静态内部类创建对象的格式：

​							格式：外部类名.内部类名 对象名 = new 外部类名.内部类构造器;

​							例如：Outer.Inner in =  new Outer.Inner();

​						静态内部类中是否可以直接访问外部类的静态成员？

​							可以, 外部类的静态成员只有一份可以被共享访问

​						静态内部类中是否可以直接访问外部类的实例成员？

​							不可以的, 外部类的实例成员必须用外部类对象访问

#### 						2）成员内部类

​							成员内部类就是无static修饰的内部类, 属于外部类的对象

​							JDK16之前,成员内部类中不能定义静态成员, JDK 16开始可以定义静态成员

​								public class Outer {    

​									// 成员内部类    

​									public class Inner {       

​									}

​								}

​							成员内部类创建对象的格式：

​									格式：外部类名.内部类名 对象名 = new  外部类构造器.new 内部类构造器();

​									例如：Outer.Inner in =  new Outer().new  Inner();

​							成员内部类中是否可以直接访问外部类的静态成员？

​									可以, 外部类的静态成员只有一份可以被共享访问

​							成员内部类的实例方法中是否可以直接访问外部类的实例成员？

​									可以, 因为必须先有外部类对象,才能有成员内部类对象, 所以可以直接访问外部类对象的实例成员

#### 						3）局部内部类

​						局部内部类放在方法、代码块、构造器等执行体中

​						局部内部类的类文件名为： 外部类$N内部类.class

#### 						4）匿名内部类

​						本质上是一个没有名字的局部内部类, 定义在方法中、代码块、构造器等执行体中

​						匿名内部类的作用：

​							方便创建子类对象,目的为了简化代码编写

​						匿名内部类的格式：

​							new 类|抽象类名|或者接口名() {    

​									重写方法;

​							};

​						匿名内部类的特点：

​							匿名内部类是一个没有名字的内部类

​							匿名内部类写出来就会产生一个匿名内部类的对象

​							匿名内部类的对象类型相当于是当前new的那个的类型的子类类型

​						匿名内部类的常见形式：

​							匿名内部类可以作为方法的实际参数进行传输

## 21）对象的初始化化流程

    1. new对象，先找到class文件加载到内存中
    2. 执行该类的static代码, 如果有的话, 静态代码块对该类进行初始化
    3. 在堆内存中开辟空间, 分配内存地址
    4. 在堆内存中建立对象的特有属性, 并进行默认初始化
    5. 对对象进行显示初始化
    6. 对对象进行构造代码块初始化
    7. 对对象进行对应的构造函数初始化
    8. 将对象的内存地址赋值给栈内存中的变量

## 22）Lambda表达式（后续章节详解）

​		Lambda表达式是JDK 8开始后的一种新语法形式

### 		1. 语法形式：

​			(匿名内部类被重写方法的形参列表) -> {   

​				被重写方法的方法体代码

​			}

​			注：-> 是语法形式, 无实际含义

### 		2. 作用：

​			简化匿名内部类的代码写法

​			同时Lambda表达式只能简化函数式接口的匿名内部类的写法形式

### 		3. 什么是函数式接口？

​			必须是接口, 且接口中有且仅有一个抽象方法的形式

### 		4. Lambda表达式的省略写法

​			1. 参数类型可以省略不写

​			2. 如果只有一个参数, 参数类型可以省略，同时()也可以省略

​			3. 如果Lambda表达式的方法体代码只有一行代码, 可以省略大括号不写,同时要省略分号！

​			4. 如果Lambda表达式的方法体代码只有一行代码, 可以省略大括号不写

​				此时, 如果这行代码是return语句, 必须省略return不写, 同时也必须省略";"不写

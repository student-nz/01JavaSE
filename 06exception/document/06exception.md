# 六、exception

## 1）什么是异常

​		异常是程序在“编译”或者“执行”的过程中可能出现的问题（语法错误不算在异常体系中）

​		比如:数组索引越界、空指针异常、 日期格式化异常，等…

## 2）为什么要学习异常?

​		异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止

​		研究异常并且避免异常，然后提前处理异常，体现的是程序的安全, 健壮性

## 3）异常体系

​		![image-20221014181403599](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\06exception\document\assets\异常体系.png)

### 1. Error

​		系统级别问题、JVM退出等，代码无法控制

### 2. Exception

​		java.lang包下，称为异常类，它表示程序本身可以处理的问题

### 3. RuntimeException及其子类

​		运行时异常，编译阶段不会报错(如：空指针异常，数组索引越界异常) 

### 4. 除RuntimeException之外所有的异常

​		编译时异常，编译期必须处理的，否则程序不能通过编译(如：日期格式化异常)

### 5. 编译时异常和运行时异常

![image-20221014181720031](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\06exception\document\assets\编译时异常和运行时异常.png)

## 4）运行时异常

​	运行时异常就是直接继承自RuntimeException或者其子类，编译阶段不会报错，运行时可能出现的错误

### 1. 运行时异常示例

​		数组索引越界异常: ArrayIndexOutOfBoundsException

​		空指针异常 : NullPointerException，直接输出没有问题，但是调用空指针的变量的功能就会报错

​		数学操作异常：ArithmeticException

​		类型转换异常：ClassCastException

​		数字转换异常： NumberFormatException

​		运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，程序员自己的水平有问题！

### 2. 编译时异常

​		不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过

#### 	1）编译时异常的作用是什么？

​		担心程序员的技术不行，在编译阶段就爆出一个错误, 目的在于提醒不要出错!

## 5）异常的默认处理流程

​	默认的异常处理机制并不好，一旦真的出现异常，程序立即死亡！

​	1. 默认会在出现异常的代码那里自动的创建一个异常对象：如：ArithmeticException

​	2. 异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机

​	3. 虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据

​	4. 直接从当前执行的异常点干掉当前程序

​	5. 后续代码没有机会执行，因为程序已经死亡

## 6）编译时异常的处理机制

​	编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过

### 1. 编译时期处理异常三种方案

#### 	1）第一种方案throws

​			出现异常直接抛出去给调用者，调用者也继续抛出去

​			throws：用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理，声明异常列表

​			这种该方式不太好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡

​			exception代表抛出一切异常

​			![image-20221014183057118](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\06exception\document\assets\第一种方案throws.png)

#### 	2）第二种方案try…catch…

​			出现异常自己捕获处理，不麻烦别人

​			监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理

​			这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行

![image-20221014183151635](D:\yjxz\Review_outline\yjxz\background\_01JavaSE\06exception\document\assets\第二种方案try…catch….png)

#### 	3）第三种方案前两者结合

​			前两者结合，出现异常直接抛出去给调用者，调用者捕获处理

​			方法直接将异通过throws抛出去给调用者

​			调用者收到异常后直接捕获处理

## 7）运行时异常的处理机制

​		运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以

### 	规范建议处理：

​		按照规范建议还是处理：建议在最外层调用处集中捕获处理即可

## 8）自定义异常

### 	1. 为什么自定义异常？

​			Java无法为这个世界上全部的问题提供异常类

​			如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了

### 	2. 自定义异常的好处

​			1. 可以使用异常的机制管理业务问题，如提醒程序员开发哪些业务出问题了

​			2. 同时一旦出现bug，可以用异常的形式清晰的指出出错的地方

### 	3. 自定义异常的分类

#### 		1）自定义编译时异常

​				作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理

​				1. 定义一个异常类继承Exception

​				2. 重写构造器

​				3. 在出现异常的地方用throw new 自定义对象抛出

#### 		2）自定义运行时异常

​				作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！

​				1. 定义一个异常类继承RuntimeException

​				2. 重写构造器

​				3. 在出现异常的地方用throw new 自定义对象抛出!

## 9）finally 语句

​			finally 放在catch后 无论异常是否发生  都会执行的代码
